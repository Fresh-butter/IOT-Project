#include <MFRC522v2.h>
#include <MFRC522DriverSPI.h>
#include <MFRC522DriverPinSimple.h>
#include <MFRC522Debug.h>
#include <TinyGPS++.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <time.h> // Added for NTP time configuration

// WiFi credentials
const char* ssid = "Nav";       // Replace with your WiFi SSID
const char* password = "Navneet123#"; // Replace with your WiFi password

// API endpoint
const char* apiEndpoint = "https://iot-project-c3wb.onrender.com/api/logs/";

// Train identification (configure as needed)
const char* TRAIN_ID = "205";
const char* TRAIN_REF = "680296fc63fe290a1ff7e5c4";
const bool IS_TEST = true;

// Pin definitions
#define RXD2 16
#define TXD2 17
#define GPS_BAUD 9600
#define RFID_SS_PIN 5

// Minimum satellites required for valid GPS data
#define MIN_SATELLITES_FOR_VALID_DATA 3

// NTP configuration
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 19800; // IST offset: 5 hours 30 minutes in seconds
const int   daylightOffset_sec = 0; // No DST in India

// RFID setup
MFRC522DriverPinSimple ss_pin(RFID_SS_PIN);
MFRC522DriverSPI driver{ss_pin};
MFRC522 mfrc522{driver};

// GPS setup
TinyGPSPlus gps;
HardwareSerial gpsSerial(2);

// Data storage
struct SensorData {
  String rfidUid = "null";
  float latitude = 0;
  float longitude = 0;
  float speed = 0;
  float altitude = 0;
  int satellites = 0;
  float hdop = 0;
  String dateTime = "";
  String isoDateTime = "";  // ISO8601 format for API
  
  // Validity flags
  bool rfidValid = false;
  bool gpsValid = false;
};

SensorData sensorData;

// Timing control
unsigned long lastPrintTime = 0;
unsigned long PRINT_INTERVAL = 6000; // Can be modified as needed
unsigned long lastWifiCheckTime = 0;
const unsigned long WIFI_CHECK_INTERVAL = 30000; // Check WiFi every 30 seconds

void setup() {
  Serial.begin(115200);
  while (!Serial);
  
  // Initialize RFID
  mfrc522.PCD_Init();
  
  // Initialize GPS
  gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);
  
  // Configure NTP with IST offset (5:30)
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  
  // Attempt initial time sync
  Serial.println("Attempting to sync time...");
  struct tm timeinfo;
  int timeRetries = 0;
  while(!getLocalTime(&timeinfo) && timeRetries < 5) {
    Serial.print(".");
    delay(1000);
    timeRetries++;
  }
  
  if(timeRetries < 5) {
    Serial.println("\nTime synchronized with NTP server!");
  } else {
    Serial.println("\nFailed to sync time, will retry later");
  }
  
  // Wait for initial WiFi connection before proceeding
  Serial.println("Waiting for WiFi connection...");
  while (WiFi.status() != WL_CONNECTED) {
    connectToWifi();
    delay(5000); // Wait 5 seconds between connection attempts
  }
  
  Serial.println("GPS, RFID Reader, and WiFi initialized successfully");
}

void loop() {
  // Process RFID
  readRfidCard();
  
  // Process GPS
  readGpsData();
  
  // Check WiFi connection periodically
  if (millis() - lastWifiCheckTime >= WIFI_CHECK_INTERVAL) {
    if (WiFi.status() != WL_CONNECTED) {
      connectToWifi();
    }
    lastWifiCheckTime = millis();
  }
  
  // Print data and send to API at specified interval
  if (millis() - lastPrintTime >= PRINT_INTERVAL) {
    printCombinedData();
    sendDataToAPI();
    
    // Reset RFID data if no new card was detected in this cycle
    if (!sensorData.rfidValid) {
      sensorData.rfidUid = "null";
    }
    sensorData.rfidValid = false;
    
    lastPrintTime = millis();
  }
}

void connectToWifi() {
  Serial.println("Connecting to WiFi...");
  WiFi.begin(ssid, password);
  
  // Wait for connection - with timeout
  unsigned long startAttemptTime = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 10000) {
    delay(500);
    Serial.print(".");
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("");
    Serial.print("Connected to WiFi network with IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("");
    Serial.println("Failed to connect to WiFi. Will retry later.");
  }
}

void readRfidCard() {
  if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
    sensorData.rfidUid = "";
    for (byte i = 0; i < mfrc522.uid.size; i++) {
      if (mfrc522.uid.uidByte[i] < 0x10) {
        sensorData.rfidUid += "0"; 
      }
      sensorData.rfidUid += String(mfrc522.uid.uidByte[i], HEX);
    }
    sensorData.rfidValid = true;
    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
  }
}

void readGpsData() {
  while (gpsSerial.available() > 0) {
    if (gps.encode(gpsSerial.read())) {
      // Check if we have enough satellites for valid GPS data
      sensorData.satellites = gps.satellites.isValid() ? gps.satellites.value() : 0;
      sensorData.gpsValid = (sensorData.satellites >= MIN_SATELLITES_FOR_VALID_DATA);
      
      // Update location data
      if (gps.location.isValid() && sensorData.gpsValid) {
        sensorData.latitude = gps.location.lat();
        sensorData.longitude = gps.location.lng();
      }
      
      // Update speed and other data
      if (gps.speed.isValid() && sensorData.gpsValid) {
        sensorData.speed = gps.speed.kmph();
      }
      
      if (gps.altitude.isValid() && sensorData.gpsValid) {
        sensorData.altitude = gps.altitude.meters();
      }
      
      if (gps.hdop.isValid()) {
        sensorData.hdop = gps.hdop.value() / 100.0;
      }
      
      // We're not using GPS time anymore - removed time handling code
    }
  }
}

void printCombinedData() {
  Serial.println("\n----- COMBINED DATA -----");
  
  // Print RFID data
  Serial.print("RFID Card UID: ");
  Serial.println(sensorData.rfidUid);
  
  // Print GPS data
  Serial.println("GPS Data:");
  Serial.print("  Satellites: "); 
  Serial.println(sensorData.satellites);
  
  // Print GPS quality indicator
  Serial.print("  GPS Fix Quality: ");
  Serial.println(sensorData.gpsValid ? "Valid" : "Invalid");
  
  // Print location data
  Serial.print("  Latitude: ");
  Serial.println(sensorData.gpsValid ? String(sensorData.latitude, 5) : "null");
  
  Serial.print("  Longitude: "); 
  Serial.println(sensorData.gpsValid ? String(sensorData.longitude, 5) : "null");
  
  // Print speed data
  Serial.print("  Speed: ");
  if (sensorData.gpsValid) {
    Serial.print(sensorData.speed);
    Serial.println(" km/h");
  } else {
    Serial.println("null");
  }
  
  // Print altitude data
  Serial.print("  Altitude: ");
  if (sensorData.gpsValid) {
    Serial.print(sensorData.altitude);
    Serial.println(" meters");
  } else {
    Serial.println("null");
  }
  
  // Print HDOP data
  Serial.print("  HDOP: "); 
  Serial.println(gps.hdop.isValid() ? String(sensorData.hdop) : "null");
  
  // Print date/time data - can be valid even without good GPS fix
  Serial.print("  Date/Time: ");
  Serial.println(gps.date.isValid() && gps.time.isValid() ? sensorData.dateTime : "null");
  
  Serial.println("-------------------------------------------\n");
}

String getCurrentTimeIST() {
  struct tm timeinfo;
  char timeString[30];
  
  // Try to get time directly
  if(!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain time, forcing NTP sync...");
    
    // Disconnect and reconnect to WiFi to ensure better NTP sync
    if (WiFi.status() == WL_CONNECTED) {
      WiFi.disconnect();
      delay(1000);
      connectToWifi();
      delay(1000);
    }
    
    // Force NTP resync
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    delay(2000); // Give more time for sync
    
    // Try again
    if(!getLocalTime(&timeinfo)) {
      return "unknown";
    }
  }
  
  // Simple verification of reasonable time
  if(timeinfo.tm_year + 1900 < 2023) {
    Serial.println("NTP returned invalid year: " + String(timeinfo.tm_year + 1900));
    return "unknown";
  }
  
  // Debug print raw time components
  Serial.print("Raw time - Year: ");
  Serial.print(timeinfo.tm_year + 1900);
  Serial.print(", Month: ");
  Serial.print(timeinfo.tm_mon + 1);
  Serial.print(", Day: ");
  Serial.print(timeinfo.tm_mday);
  Serial.print(", Hour: ");
  Serial.print(timeinfo.tm_hour);
  Serial.print(", Minute: ");
  Serial.print(timeinfo.tm_min);
  Serial.print(", Second: ");
  Serial.println(timeinfo.tm_sec);
  
  // Format as ISO8601 with IST timezone
  strftime(timeString, sizeof(timeString), "%Y-%m-%dT%H:%M:%S+05:30", &timeinfo);
  return String(timeString);
}

void sendDataToAPI() {
  // Check WiFi connection and attempt to reconnect if necessary
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected. Attempting to reconnect...");
    connectToWifi();
    
    // If reconnection failed, skip API call
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi reconnection failed. Cannot send data to API.");
      return;
    }
  }
  
  // Proceed regardless of GPS validity
  HTTPClient http;
  http.begin(apiEndpoint);
  http.addHeader("Content-Type", "application/json");
  
  // Create JSON payload
  StaticJsonDocument<512> jsonDoc;
  jsonDoc["train_id"] = TRAIN_ID;
  jsonDoc["train_ref"] = TRAIN_REF;
  
  // Simplified timestamp handling
  String currentTime = getCurrentTimeIST();
  if(currentTime != "unknown") {
    jsonDoc["timestamp"] = currentTime;
    Serial.println("Sending timestamp: " + currentTime);
  } else {
    Serial.println("Warning: No valid time available");
    jsonDoc["timestamp"] = "unavailable";
  }
  
  // Fix for the RFID null assignment
  if (sensorData.rfidUid != "null") {
    jsonDoc["rfid_tag"] = sensorData.rfidUid;
  } else {
    jsonDoc["rfid_tag"] = nullptr;
  }
  
  // Handle location field based on GPS validity
  if (sensorData.gpsValid) {
    // Add location as array with valid GPS data
    JsonArray locationArray = jsonDoc.createNestedArray("location");
    locationArray.add(sensorData.longitude); // API format is [longitude, latitude]
    locationArray.add(sensorData.latitude);
  } else {
    // For invalid GPS, use null value as per schema
    jsonDoc["location"] = nullptr;
  }
  
  // Set accuracy based on HDOP or invalid for no GPS
  String accuracy;
  if (!sensorData.gpsValid) {
    accuracy = "poor"; // Using "poor" instead of "invalid" 
  } else if (sensorData.hdop < 1.0) {
    accuracy = "excellent";
  } else if (sensorData.hdop < 2.0) {
    accuracy = "good";
  } else if (sensorData.hdop < 5.0) {
    accuracy = "moderate";
  } else {
    accuracy = "poor";
  }
  jsonDoc["accuracy"] = accuracy;
  jsonDoc["is_test"] = IS_TEST;
  
  // Serialize JSON to string
  String jsonPayload;
  serializeJson(jsonDoc, jsonPayload);
  
  // Send the request
  Serial.println("Sending data to API...");
  Serial.println(jsonPayload);
  
  int httpResponseCode = http.POST(jsonPayload);
  
  if (httpResponseCode > 0) {
    String response = http.getString();
    Serial.println("HTTP Response code: " + String(httpResponseCode));
    Serial.println("Response: " + response);
  } else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
    Serial.println("API request failed");
  }
  
  http.end();
}
